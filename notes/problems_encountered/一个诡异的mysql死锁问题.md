### 问题描述

在进行批量插入时拆分出来了多个事务且同时插入时 部分事务产生了死锁导致插入失败

### 问题定位

起初测试环境复现未发现该问题  
后续测试人员无意间造出来的数据复现到了该问题  
最终锁定到有重复数据（主键冲突）时必现

### 问题复现

#### 创建表

```
CREATE TABLE `test_lock` (
`id` int NOT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

#### 复现步骤

1. **同时启动三个事务来执行同一个sql 不要提交**
   ```
   BEGIN;
   insert into test_lock values (1);
   ROLLBACK;
   ```

2. **其中一个事务回滚**
3. **剩下的两个中最后开启的事务会报错**
   1213 - Deadlock found when trying to get lock; try restarting transaction

### 原因分析

1. **事务执行流程与锁获取初始情况**  
   当三个事务同时执行 insert into test_lock values (1); 时，为了检查是否存在主键冲突，它们都会尝试获取目标记录（id =
   1）的共享锁（S 锁）。此时，会有一个事务（假设为事务 T1）先成功获取到了排它锁（X 锁），而另外两个事务（事务 T2 和事务
   T3）处于等待获取共享锁（S 锁）的状态。
2. **第一个事务回滚后的状态变化**  
   当事务 T1 回滚并释放了排它锁（X 锁）后，事务 T2 和事务 T3 会竞争获取共享锁（S 锁）。假设事务 T2 率先获取到了共享锁（S
   锁），此时它开始检查是否存在主键冲突。
3. **锁升级与死锁的形成**

- **事务 T2 锁升级需求**：事务 T2 在获取共享锁（S 锁）完成检查后，发现记录不存在，于是需要将共享锁（S 锁）升级为排它锁（X
  锁）以执行插入操作。然而，在 InnoDB 中，当一个事务要将共享锁（S 锁）升级为排它锁（X 锁）时，为了保证操作的一致性和避免并发问题，会阻止其他事务再获取该记录的共享锁（S
  锁）。所以事务 T2 必须等待其他事务（这里指事务 T3）不获取共享锁（S 锁），才能完成锁的升级。
- **事务 T3 等待获取 S 锁**：事务 T3 一直在等待获取共享锁（S 锁），但由于事务 T2 有将共享锁（S 锁）升级为排它锁（X 锁）的需求，事务
  T3 只能等待事务 T2 释放共享锁（S 锁）或者完成锁升级操作。
- **死锁局面形成**：这样就形成了循环等待的死锁局面，事务 T2 等待事务 T3 不获取共享锁（S 锁）以便自己能将锁升级为排它锁（X
  锁），而事务 T3 等待事务 T2 释放共享锁（S 锁）以便自己能获取共享锁（S 锁）。

4. **总结**  
   在这个场景中，正是因为一个事务（如 T2）有将共享锁（S 锁）升级为排它锁（X 锁）的需求，导致它阻止了另一个事务（如 T3）获取共享锁（S
   锁），而另一个事务又在等待获取共享锁（S 锁），从而形成了死锁。

### 相关sql

查询数据表加锁状态

```
SELECT
	engine_transaction_id,
	thread_id,
	object_name,
	index_name,
	lock_type,
	lock_mode,
	lock_status 
FROM
	PERFORMANCE_SCHEMA.data_locks
```

查看元数据锁加锁状态

```
SELECT
	owner_thread_id,
	object_name,
	object_type,
	object_schema,
	lock_type,
	lock_status 
FROM
	PERFORMANCE_SCHEMA.metadata_locks;
```

### 知识点

当对一张表进行增删改查的时候，加MDL读锁(S)；当对表结构进行变更操作的时候，加MDL写锁(X)

#### MYSQL锁体系

**以锁粒度的维度划分**

- 全局锁：锁定数据库中的所有表。加上全局锁之后，整个数据库只能允许读，不允许做任何写操作
- 表级锁：每次操作锁住整张表。主要分为三类
    - 表锁（分为表共享读锁 read lock、表独占写锁 write lock）
    - 元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构
    - 意向锁（分为意向共享锁、意向排他锁）：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查
- 行级锁：每次操作锁住对应的行数据。主要分为三类
    - 记录锁 / Record 锁：也就是行锁，一条记录和一行数据是同一个意思。防止其他事务对此行进行update和delete，在RC、RR隔离级别下都支持
  - 间隙锁 / Gap 锁：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
  - 临键锁 / Next-Key 锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能，仅在RR隔离级别下支持
- 以互斥性的角度划分
    - 共享锁 / S锁：不同事务之间不会相互排斥、可以同时获取的锁
    - 排他锁 / X锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁
    - 共享排他锁 / SX锁：MySQL5.7版本中新引入的锁，主要是解决SMO带来的问题
- 以操作类型的维度划分
    - 读锁：查询数据时使用的锁
    - 写锁：执行插入、删除、修改、DDL语句时使用的锁
- 以加锁方式的维度划分
    - 显示锁：编写SQL语句时，手动指定加锁的粒度
    - 隐式锁：执行SQL语句时，根据隔离级别自动为SQL操作加锁
- 以思想的维度划分
    - 乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁
    - 悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行