# cglib代理会失效的几个场景

## 1.目标类是 final 类

**原因** ：
CGLib 通过生成目标类的子类来实现代理。如果目标类被声明为 final，则无法继承，代理类无法生成。
**解决方案**：

- 改用 JDK 动态代理（需目标类实现接口）。
- 修改目标类，移除 final 修饰符（需控制代码所有权）。

## 2.目标方法是 final 方法

**原因** ：
CGLib 通过重写父类方法插入代理逻辑。若目标方法是 final，子类无法覆盖该方法，代理逻辑无法生效。
**解决方案**：

- 避免对 final 方法进行代理。
- 重构目标类，移除 final 修饰符。
- 使用基于接口的 JDK 动态代理（若目标类实现接口）。

## 3.目标类没有默认构造函数（无参构造方法）

**原因** ：
CGLib 在生成代理类时，需要调用父类的默认构造函数（无参构造方法）。如果目标类没有默认构造函数，且未显式指定其他构造函数，代理类将无法实例化。
**解决方案**：

- 添加默认构造函数。
- 使用 Objenesis 库绕过构造函数调用（需权衡风险，如 Spring 默认支持此方式）。
- 通过 Enhancer 的 setCallbackFilter 手动处理构造逻辑（需复杂定制）。

## 4.静态方法（Static Methods）

**原因** ：
CGLib 通过子类重写实例方法实现代理，而静态方法属于类级别，无法被覆盖。
**解决方案**：

- 避免代理静态方法，改用其他方式（如工具类切面）。
- 使用编译时 AOP 工具（如 AspectJ）。

## 5.私有方法（Private Methods）

**原因** ：
CGLib 无法代理私有方法，因为子类无法访问父类的私有方法。
**解决方案**：

- 将方法改为 protected 或 public。
- 使用反射强制调用私有方法（破坏封装性，不推荐）。

